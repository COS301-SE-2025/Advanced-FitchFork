name: "Start servers (API, Code Manager, Frontend)"
description: "Build Docker images, then start required servers in background, wait for health URLs, and expose logs"

inputs:
  start-frontend:
    description: "Whether to start frontend (true/false)"
    required: false
    default: "false"
  api-cmd:
    description: "Command to start API"
    required: false
    default: "cargo run -p api"
  code-cmd:
    description: "Command to start Code Manager"
    required: false
    default: "cargo run -p code_manager"
  frontend-cmd:
    description: "Command to start Frontend"
    required: false
    default: "npm run dev -- --port 5173"
  api-url:
    description: "API health URL"
    required: false
    default: "http://localhost:3000/api/health"
  code-url:
    description: "Code Manager health URL"
    required: false
    default: "http://localhost:5000/health"
  frontend-url:
    description: "Frontend URL to wait for"
    required: false
    default: "http://localhost:5173"

runs:
  using: "composite"
  steps:
    - name: Install wait-on
      shell: bash
      run: npm i -g wait-on

    # --- Load backend env vars so processes can start correctly ---
    - name: Load backend .env
      shell: bash
      run: |
        set -a
        source backend/.env
        set +a
        # For local run: don't force HOST or CODE_MANAGER_HOST

    # ---- Build Docker images first ----
    - name: Build Docker images
      shell: bash
      run: docker build -t universal-runner:latest -f images/Dockerfile .
      working-directory: backend/code_manager

    - name: Start API
      shell: bash
      working-directory: backend
      run: |
        nohup ${INPUT_API_CMD} > ../api.log 2>&1 & echo $! > ../api.pid
      env:
        INPUT_API_CMD: ${{ inputs.api-cmd }}

    - name: Start Code Manager
      shell: bash
      working-directory: backend
      run: |
        nohup ${INPUT_CODE_CMD} > ../code.log 2>&1 & echo $! > ../code.pid
      env:
        INPUT_CODE_CMD: ${{ inputs.code-cmd }}

    - name: Start Frontend (optional)
      if: ${{ inputs.start-frontend == 'true' }}
      shell: bash
      working-directory: frontend
      run: |
        nohup ${INPUT_FRONTEND_CMD} > ../frontend.log 2>&1 & echo $! > ../frontend.pid
      env:
        INPUT_FRONTEND_CMD: ${{ inputs.frontend-cmd }}

    - name: Wait for API + Code Manager
      shell: bash
      run: |
        echo "Waiting for API at ${API_URL} and Code Manager at ${CODE_URL}"
        sleep 3
        echo "--- First lines of API log ---"
        head -n 20 api.log || true
        echo "--- First lines of Code Manager log ---"
        head -n 20 code.log || true
        wait-on -t 600000 "${API_URL}" "${CODE_URL}"
      env:
        API_URL: ${{ inputs.api-url }}
        CODE_URL: ${{ inputs.code-url }}

    - name: Wait for Frontend (optional)
      if: ${{ inputs.start-frontend == 'true' }}
      shell: bash
      run: |
        wait-on -t 600000 "${FRONTEND_URL}"
      env:
        FRONTEND_URL: ${{ inputs.frontend-url }}

    - name: Expose logs path
      id: logs
      shell: bash
      run: echo "logs-path=$GITHUB_WORKSPACE" >> "$GITHUB_OUTPUT"

    # Stop servers on post-job
    - name: Register post-job cleanup
      shell: bash
      run: |
        cat > /tmp/stop_servers.sh <<'EOS'
        set -e
        for f in api.pid code.pid frontend.pid; do
          if [ -f "$f" ]; then
            kill "$(cat "$f")" 2>/dev/null || true
          fi
        done
        EOS
        chmod +x /tmp/stop_servers.sh