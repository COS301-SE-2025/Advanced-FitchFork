use chrono::{DateTime, Utc};
use sea_orm::entity::prelude::*;
use sea_orm::{ActiveValue::Set, DatabaseConnection, EntityTrait};
use std::fs;
use std::path::PathBuf;
use util::paths::{ensure_dir, memo_output_dir, storage_root};

/// Represents the output generated by the interpreter for an assignment memo.
///
/// Each output is linked to a specific assignment and task.
/// Timestamps are included to track when the file was created and last updated.
#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "assignment_memo_outputs")]
pub struct Model {
    /// Primary key of the output.
    #[sea_orm(primary_key)]
    pub id: i64,
    /// ID of the related assignment.
    pub assignment_id: i64,
    /// ID of the related task.
    pub task_id: i64,
    /// Relative file path from the storage root.
    pub path: String,
    /// Timestamp when the output was created.
    pub created_at: DateTime<Utc>,
    /// Timestamp when the output was last updated.
    pub updated_at: DateTime<Utc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    /// Link to the related assignment.
    #[sea_orm(
        belongs_to = "super::assignment::Entity",
        from = "Column::AssignmentId",
        to = "super::assignment::Column::Id"
    )]
    Assignment,

    /// Link to the related task.
    #[sea_orm(
        belongs_to = "super::assignment_task::Entity",
        from = "Column::TaskId",
        to = "super::assignment_task::Column::Id"
    )]
    AssignmentTask,
}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    /// Saves a memo output file to disk and creates or updates its metadata in the database.
    pub async fn save_file(
        db: &DatabaseConnection,
        assignment_id: i64,
        task_id: i64,
        filename: &str,
        bytes: &[u8],
    ) -> Result<Self, DbErr> {
        let now = Utc::now();

        // Create DB row first to get an ID we can use in the stored filename
        let partial = ActiveModel {
            assignment_id: Set(assignment_id),
            task_id: Set(task_id),
            path: Set(String::new()),
            created_at: Set(now),
            updated_at: Set(now),
            ..Default::default()
        };

        let inserted: Model = partial.insert(db).await?;

        // Determine the stored filename: "{id}.{ext}" (matches original behavior)
        let ext = PathBuf::from(filename)
            .extension()
            .map(|e| e.to_string_lossy().to_string());

        let stored_filename = match ext {
            Some(ext) => format!("{}.{}", inserted.id, ext),
            None => inserted.id.to_string(),
        };

        // Fetch module_id to build directory
        let assignment = super::assignment::Entity::find_by_id(assignment_id)
            .one(db)
            .await
            .map_err(|e| DbErr::Custom(format!("DB error finding assignment: {e}")))?
            .ok_or_else(|| DbErr::Custom("Assignment not found".to_string()))?;

        let module_id = assignment.module_id;

        // Ensure directory exists (inline path util)
        let dir_path = memo_output_dir(module_id, assignment_id);
        ensure_dir(&dir_path)
            .map_err(|e| DbErr::Custom(format!("Failed to create directory: {e}")))?;

        // Write file
        let file_path = dir_path.join(&stored_filename);
        fs::write(&file_path, bytes)
            .map_err(|e| DbErr::Custom(format!("Failed to write file: {e}")))?;

        // Store relative path from storage root (inline)
        let relative_path = file_path
            .strip_prefix(storage_root())
            .unwrap()
            .to_string_lossy()
            .to_string();

        let mut model: ActiveModel = inserted.into();
        model.path = Set(relative_path);
        model.updated_at = Set(Utc::now());

        model.update(db).await
    }
}
