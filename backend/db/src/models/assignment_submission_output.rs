use chrono::{DateTime, Utc};
use sea_orm::entity::prelude::*;
use sea_orm::{ActiveValue::Set, DatabaseConnection, EntityTrait};
use std::fs;
use std::io;
use std::io::ErrorKind;
use std::path::PathBuf;

use crate::models::assignment_submission;
use util::paths::{ensure_dir, storage_root, submission_output_dir};

/// Represents the output generated by a student's submission for an assignment task.
#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "assignment_submission_outputs")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    pub task_id: i64,
    pub submission_id: i64,
    pub path: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::assignment_task::Entity",
        from = "Column::TaskId",
        to = "super::assignment_task::Column::Id"
    )]
    AssignmentTask,

    #[sea_orm(
        belongs_to = "super::user::Entity",
        from = "Column::SubmissionId",
        to = "super::user::Column::Id"
    )]
    AssignmentSubmission,
}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    /// Absolute disk path from the stored relative `path`.
    pub fn full_path(&self) -> PathBuf {
        storage_root().join(&self.path)
    }

    /// Delete all outputs (files + rows) for a submission.
    pub async fn delete_for_submission(
        db: &DatabaseConnection,
        submission_id: i64,
    ) -> Result<(), DbErr> {
        use sea_orm::QueryFilter;

        let outputs = Entity::find()
            .filter(Column::SubmissionId.eq(submission_id))
            .all(db)
            .await?;

        for output in outputs {
            let path = output.full_path();
            if path.exists() {
                if let Err(e) = fs::remove_file(&path) {
                    eprintln!("Failed to delete file {:?}: {}", path, e);
                }
            }
            let am: ActiveModel = output.into();
            am.delete(db).await?;
        }

        Ok(())
    }

    pub async fn save_file(
        db: &DatabaseConnection,
        task_id: i64,
        submission_id: i64,
        filename: &str,
        bytes: &[u8],
    ) -> Result<Self, DbErr> {
        let now = Utc::now();

        let inserted: Model = ActiveModel {
            task_id: Set(task_id),
            submission_id: Set(submission_id),
            path: Set(String::new()),
            created_at: Set(now),
            updated_at: Set(now),
            ..Default::default()
        }
        .insert(db)
        .await?;

        let ext = PathBuf::from(filename)
            .extension()
            .map(|e| e.to_string_lossy().to_string());
        let stored_filename = ext
            .map(|ext| format!("{}.{}", inserted.id, ext))
            .unwrap_or_else(|| inserted.id.to_string());

        // Lookup submission → assignment → module to build canonical dir
        let submission = super::assignment_submission::Entity::find_by_id(submission_id)
            .one(db)
            .await
            .map_err(|e| DbErr::Custom(format!("DB error finding submission: {}", e)))?
            .ok_or_else(|| DbErr::Custom("Submission not found".to_string()))?;

        let assignment = super::assignment::Entity::find_by_id(submission.assignment_id)
            .one(db)
            .await
            .map_err(|e| DbErr::Custom(format!("DB error finding assignment: {}", e)))?
            .ok_or_else(|| DbErr::Custom("Assignment not found".to_string()))?;

        let dir_path = submission_output_dir(
            assignment.module_id,
            assignment.id,
            submission.user_id,
            submission.attempt,
        );
        ensure_dir(&dir_path)
            .map_err(|e| DbErr::Custom(format!("Failed to create directory: {e}")))?;

        let file_path = dir_path.join(&stored_filename);
        fs::write(&file_path, bytes)
            .map_err(|e| DbErr::Custom(format!("Failed to write file: {e}")))?;

        let relative_path = file_path
            .strip_prefix(storage_root())
            .unwrap()
            .to_string_lossy()
            .to_string();

        let mut model: ActiveModel = inserted.into();
        model.path = Set(relative_path);
        model.updated_at = Set(Utc::now());

        model.update(db).await
    }

    /// Read all output files for a submission id, returning (task_id, content).
    pub async fn get_output(
        db: &DatabaseConnection,
        module_id: i64,
        assignment_id: i64,
        submission_id: i64,
    ) -> io::Result<Vec<(i64, String)>> {
        let submission = assignment_submission::Entity::find_by_id(submission_id)
            .one(db)
            .await
            .map_err(|e| io::Error::new(ErrorKind::Other, format!("DB error: {}", e)))?
            .ok_or_else(|| io::Error::new(ErrorKind::NotFound, "Submission not found"))?;

        let base_dir_path = submission_output_dir(
            module_id,
            assignment_id,
            submission.user_id,
            submission.attempt,
        );

        if !base_dir_path.exists() {
            return Err(io::Error::new(
                ErrorKind::NotFound,
                format!(
                    "Submission output directory {:?} does not exist",
                    base_dir_path
                ),
            ));
        }

        let mut results = Vec::new();
        for entry in fs::read_dir(&base_dir_path)? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                let file_path = entry.path();
                if let Some(stem) = file_path.file_stem().and_then(|n| n.to_str()) {
                    if let Ok(output_id) = stem.parse::<i64>() {
                        if let Some(output) =
                            Entity::find_by_id(output_id).one(db).await.map_err(|e| {
                                io::Error::new(ErrorKind::Other, format!("DB error: {}", e))
                            })?
                        {
                            let content = fs::read_to_string(&file_path)?;
                            results.push((output.task_id, content));
                        }
                    }
                }
            }
        }

        Ok(results)
    }
}
