use axum::{
    extract::Path,
    http::{header, StatusCode},
    response::{IntoResponse, Response},
};
use std::{env, fs, path::PathBuf};
use tokio::fs::File;
use tokio_util::io::ReaderStream;
use axum::body::Body;

/// GET /api/modules/:module_id/assignments/:assignment_id/memo_output
///
/// Download the generated memo output file for a specific assignment. Accessible to users with
/// appropriate permissions assigned to the module.
///
/// This endpoint retrieves the first available file from the memo_output directory for the specified
/// assignment. Memo output files contain the expected results for assignment tasks and are used
/// for evaluating student submissions.
///
/// ### Path Parameters
/// - `module_id` (i64): The ID of the module containing the assignment
/// - `assignment_id` (i64): The ID of the assignment to download memo output for
///
/// ### Example Request
/// ```bash
/// curl -X GET http://localhost:3000/api/modules/1/assignments/2/memo_output \
///   -H "Authorization: Bearer <token>" \
///   -OJ
/// ```
///
/// ### Success Response (200 OK)
/// The response includes the file as an attachment with appropriate headers:
/// - `Content-Type: application/octet-stream`
/// - `Content-Disposition: attachment; filename="output.txt"`
/// - File content as the response body
///
/// ### Error Responses
///
/// **404 Not Found** - Output directory or file not found
/// 
/// Output directory does not exist for assignment 2
/// 
/// or
/// 
/// No output file found in memo_output directory
/// 
///
/// **500 Internal Server Error** - File system error
/// 
/// Failed to read output directory
/// 
/// or
/// 
/// Failed to open output file
/// 
///
/// **403 Forbidden** - Insufficient permissions
/// ```json
/// {
///   "success": false,
///   "message": "Access denied"
/// }
/// ```
///
/// ### File Location
/// The endpoint looks for files in the following directory structure:
/// 
/// ASSIGNMENT_STORAGE_ROOT/
/// └── module_{module_id}/
///     └── assignment_{assignment_id}/
///         └── memo_output/
///             └── [output files]
/// 
///
/// ### File Selection
/// - The endpoint returns the first file found in the memo_output directory
/// - Files are selected in the order returned by the file system
/// - The filename is preserved in the Content-Disposition header
/// - If no filename can be determined, "output.txt" is used as default
///
/// ### Notes
/// - Memo output files are generated by the POST /generate endpoint
/// - Files are served as binary attachments for download
/// - The endpoint does not list available files; it returns the first one found
/// - Access is restricted to users with appropriate module permissions
/// - File content is streamed to avoid memory issues with large files
pub async fn get_memo_output_file(
    Path((module_id, assignment_id)): Path<(i64, i64)>,
) -> impl IntoResponse {
    let base_path = env::var("ASSIGNMENT_STORAGE_ROOT")
        .unwrap_or_else(|_| "data/assignment_files".into());

    let output_dir = PathBuf::from(base_path)
        .join(format!("module_{}", module_id))
        .join(format!("assignment_{}", assignment_id))
        .join("memo_output");

    if !output_dir.is_dir() {
        return (
            StatusCode::NOT_FOUND,
            format!("Output directory does not exist for assignment {}", assignment_id),
        )
            .into_response();
    }

    let entries = match fs::read_dir(&output_dir) {
        Ok(entries) => entries.filter_map(Result::ok).collect::<Vec<_>>(),
        Err(_) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to read output directory",
            )
                .into_response();
        }
    };

    let Some(file_entry) = entries.iter().find(|e| e.path().is_file()) else {
        return (
            StatusCode::NOT_FOUND,
            "No output file found in memo_output directory",
        )
            .into_response();
    };

    let file_path = file_entry.path();

    match File::open(&file_path).await {
        Ok(file) => {
            let stream = ReaderStream::new(file);
            let filename = file_path
                .file_name()
                .and_then(|f| f.to_str())
                .unwrap_or("output.txt");

            Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_TYPE, "application/octet-stream")
                .header(header::CONTENT_DISPOSITION, format!("attachment; filename=\"{}\"", filename))
                .body(Body::from_stream(stream))
                .unwrap()
        }
        Err(_) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            "Failed to open output file",
        )
            .into_response(),
    }
}